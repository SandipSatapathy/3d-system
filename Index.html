<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand-Tracked Particle System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            z-index: 2;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            margin: 0 0 15px 0;
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #00ffcc;
        }

        .instruction {
            font-size: 0.95rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            opacity: 0.9;
        }

        .emoji {
            font-size: 1.2rem;
            margin-right: 12px;
            background: rgba(255, 255, 255, 0.1);
            padding: 6px;
            border-radius: 8px;
        }

        #status-container {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status {
            font-size: 0.9rem;
            font-weight: 600;
            color: #ffaa00;
            transition: color 0.3s ease;
        }

        .status.ready { color: #00ffaa; }

        #action-feedback {
            position: absolute;
            top: 30px;
            right: 30px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            z-index: 2;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(-20px);
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        #action-feedback.show {
            opacity: 1;
            transform: translateY(0);
        }

        #video-preview-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 240px;
            height: 180px;
            z-index: 2;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #111;
        }

        #video-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror */
        }

        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #00ffcc;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <h1>Particle Controls</h1>
        <div class="instruction"><span class="emoji">‚úåÔ∏è</span> Peace Sign: Next Shape</div>
        <div class="instruction"><span class="emoji">‚úä</span> Fist: Change Color</div>
        <div class="instruction"><span class="emoji">ü§è</span> Pinch / Open: Expand Particles</div>
        <div class="instruction"><span class="emoji">üñê</span> Move Hand: Rotate Galaxy</div>
        
        <div id="status-container">
            <div class="status" id="status-text"><span class="loader" id="loader"></span>Initializing Camera...</div>
        </div>
    </div>

    <div id="action-feedback">Shape Changed!</div>

    <div id="video-preview-container">
        <video id="webcam" autoplay playsinline style="display:none;"></video>
        <canvas id="video-preview" width="640" height="480"></canvas>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. CONFIGURATION & STATE
        // ==========================================
        const PARTICLE_COUNT = 12000;
        const BASE_RADIUS = 12;
        
        // Physics / Particle State Arrays
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        const velocities = new Float32Array(PARTICLE_COUNT * 3);
        const baseColors = new Float32Array(PARTICLE_COUNT * 3);

        let currentShapeIndex = 0;
        let currentColorIndex = 0;
        
        // Interaction Variables
        let pinchExpansion = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;

        // Colors
        const THEMES = [
            new THREE.Color(0x00ffcc), // Cyan
            new THREE.Color(0xff0077), // Cyberpunk Pink
            new THREE.Color(0xffbb00), // Gold
            new THREE.Color(0xaa00ff), // Purple
            new THREE.Color(0xffffff)  // White
        ];
        let currentThemeColor = THEMES[0].clone();
        let targetThemeColor = THEMES[0].clone();

        // ==========================================
        // 2. THREE.JS SETUP
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Particle Texture (Soft Glowing Dot)
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        // We will assign base color variations per particle
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const intensity = 0.5 + Math.random() * 0.5;
            baseColors[i*3] = intensity;
            baseColors[i*3+1] = intensity;
            baseColors[i*3+2] = intensity;
        }
        geometry.setAttribute('color', new THREE.BufferAttribute(baseColors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.6,
            map: createGlowTexture(),
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            vertexColors: true,
            color: currentThemeColor
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // Ambient movement group
        const group = new THREE.Group();
        group.add(particleSystem);
        scene.add(group);


        // ==========================================
        // 3. SHAPE GENERATORS
        // ==========================================
        const Shapes = {
            Sphere: () => {
                const arr = new Float32Array(PARTICLE_COUNT * 3);
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const r = BASE_RADIUS + (Math.random() * 2 - 1);
                    arr[i*3] = r * Math.cos(theta) * Math.sin(phi);
                    arr[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
                    arr[i*3+2] = r * Math.cos(phi);
                }
                return arr;
            },
            Heart: () => {
                const arr = new Float32Array(PARTICLE_COUNT * 3);
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const scale = 0.8 + Math.random() * 0.4;
                    // Heart math equation
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    arr[i*3] = x * 0.6 * scale;
                    arr[i*3+1] = y * 0.6 * scale;
                    arr[i*3+2] = (Math.random() - 0.5) * 6;
                }
                return arr;
            },
            Flower: () => {
                const arr = new Float32Array(PARTICLE_COUNT * 3);
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const petals = 5;
                    // Rose curve
                    const r = BASE_RADIUS * Math.abs(Math.cos(petals * t / 2)) * (0.5 + Math.random() * 0.5);
                    arr[i*3] = r * Math.cos(t);
                    arr[i*3+1] = r * Math.sin(t);
                    arr[i*3+2] = Math.sin(petals * t) * 4 + (Math.random() - 0.5) * 2;
                }
                return arr;
            },
            Saturn: () => {
                const arr = new Float32Array(PARTICLE_COUNT * 3);
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    if (Math.random() < 0.25) {
                        // Center Planet
                        const phi = Math.acos(-1 + 2 * Math.random());
                        const theta = 2 * Math.PI * Math.random();
                        const r = 5 * Math.cbrt(Math.random());
                        arr[i*3] = r * Math.cos(theta) * Math.sin(phi);
                        arr[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
                        arr[i*3+2] = r * Math.cos(phi);
                    } else {
                        // Ring
                        const t = Math.random() * Math.PI * 2;
                        const r = 8 + Math.random() * 8;
                        arr[i*3] = r * Math.cos(t);
                        arr[i*3+1] = (Math.random() - 0.5) * 1.5;
                        arr[i*3+2] = r * Math.sin(t);
                    }
                }
                // Tilt Saturn slightly
                const tilt = 0.4;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const y = arr[i*3+1];
                    const z = arr[i*3+2];
                    arr[i*3+1] = y * Math.cos(tilt) - z * Math.sin(tilt);
                    arr[i*3+2] = y * Math.sin(tilt) + z * Math.cos(tilt);
                }
                return arr;
            },
            Fireworks: () => {
                const arr = new Float32Array(PARTICLE_COUNT * 3);
                const bursts = [
                    {x: -10, y: 8, z: -5},
                    {x: 10, y: 10, z: 2},
                    {x: 0, y: -5, z: 8},
                    {x: -8, y: -10, z: -2},
                    {x: 12, y: -2, z: -8}
                ];
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const burst = bursts[Math.floor(Math.random() * bursts.length)];
                    const phi = Math.acos(-1 + 2 * Math.random());
                    const theta = 2 * Math.PI * Math.random();
                    // concentrate more particles at edges of bursts
                    const r = 6 * Math.pow(Math.random(), 0.3); 
                    arr[i*3] = burst.x + r * Math.cos(theta) * Math.sin(phi);
                    arr[i*3+1] = burst.y + r * Math.sin(theta) * Math.sin(phi);
                    arr[i*3+2] = burst.z + r * Math.cos(phi);
                }
                return arr;
            }
        };

        const shapeKeys = Object.keys(Shapes);

        function setShape(index) {
            const newPositions = Shapes[shapeKeys[index]]();
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                targetPositions[i] = newPositions[i];
            }
        }

        // Init initial shape
        setShape(0);
        // Start particles randomly so they fly into the first shape
        for(let i=0; i<PARTICLE_COUNT * 3; i++) positions[i] = (Math.random() - 0.5) * 100;

        // UI Feedback
        function showFeedback(text) {
            const el = document.getElementById('action-feedback');
            el.innerText = text;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        // ==========================================
        // 4. ANIMATION & PHYSICS LOOP
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // Smooth color transition
            currentThemeColor.lerp(targetThemeColor, delta * 3);
            material.color.copy(currentThemeColor);

            // Smooth camera rotation based on hand position
            group.rotation.x += (targetRotationX - group.rotation.x) * 0.05;
            group.rotation.y += (targetRotationY - group.rotation.y) * 0.05;
            
            // Slow ambient rotation
            particleSystem.rotation.y = time * 0.1;
            particleSystem.rotation.z = time * 0.05;

            // Physics Loop for Particles
            const posArray = geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                
                let tx = targetPositions[idx];
                let ty = targetPositions[idx+1];
                let tz = targetPositions[idx+2];

                // Apply Pinch Expansion (Push outwards from center)
                if (pinchExpansion > 0.01) {
                    const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) || 1;
                    const expansionFactor = pinchExpansion * 30; // Max push distance
                    tx += (tx / dist) * expansionFactor;
                    ty += (ty / dist) * expansionFactor;
                    tz += (tz / dist) * expansionFactor;
                }

                // Add slight organic noise
                tx += Math.sin(time * 2 + i) * 0.2;
                ty += Math.cos(time * 2.5 + i) * 0.2;

                let cx = posArray[idx];
                let cy = posArray[idx+1];
                let cz = posArray[idx+2];

                let vx = velocities[idx];
                let vy = velocities[idx+1];
                let vz = velocities[idx+2];

                // Spring force towards target
                vx += (tx - cx) * 0.02;
                vy += (ty - cy) * 0.02;
                vz += (tz - cz) * 0.02;

                // Damping / Friction
                vx *= 0.85;
                vy *= 0.85;
                vz *= 0.85;

                posArray[idx] = cx + vx;
                posArray[idx+1] = cy + vy;
                posArray[idx+2] = cz + vz;

                velocities[idx] = vx;
                velocities[idx+1] = vy;
                velocities[idx+2] = vz;
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }


        // ==========================================
        // 5. MEDIAPIPE HAND TRACKING & GESTURES
        // ==========================================
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('video-preview');
        const canvasCtx = canvasElement.getContext('2d');
        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');

        let lastGestureTime = 0;
        const GESTURE_COOLDOWN = 1200; // ms

        // Utility: Distance between two 3D landmarks
        function getDistance(l1, l2) {
            const dx = l1.x - l2.x;
            const dy = l1.y - l2.y;
            return Math.sqrt(dx*dx + dy*dy);
        }

        // Hand posture heuristics
        function analyzeHand(landmarks) {
            const wrist = landmarks[0];
            
            // Check if fingers are extended (Tip distance to wrist > PIP distance to wrist)
            const isThumbExt = getDistance(landmarks[4], wrist) > getDistance(landmarks[2], wrist);
            const isIndexExt = getDistance(landmarks[8], wrist) > getDistance(landmarks[6], wrist);
            const isMiddleExt = getDistance(landmarks[12], wrist) > getDistance(landmarks[10], wrist);
            const isRingExt = getDistance(landmarks[16], wrist) > getDistance(landmarks[14], wrist);
            const isPinkyExt = getDistance(landmarks[20], wrist) > getDistance(landmarks[18], wrist);

            // Pinch calculation (Thumb tip to Index tip)
            const pinchDist = getDistance(landmarks[4], landmarks[8]);

            // Gestures
            const isFist = !isIndexExt && !isMiddleExt && !isRingExt && !isPinkyExt;
            const isPeace = isIndexExt && isMiddleExt && !isRingExt && !isPinkyExt;

            return { isFist, isPeace, pinchDist };
        }

        function onResults(results) {
            // Draw Preview
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw skeleton on preview
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 2});

                const handState = analyzeHand(landmarks);
                const now = performance.now();

                // 1. Pinch to Expand (continuous)
                // Normal distance is ~0.1 to 0.2. Pinched is < 0.05.
                // We want wide open fingers to expand particles, or close pinch? 
                // Let's map pinch distance directly. Open hand = larger distance.
                // Let's invert it: pinching expands.
                let targetPinch = 0;
                if (!handState.isFist && !handState.isPeace) {
                    // Map distance 0.15 (open) to 0.02 (pinched) -> 0 to 1 expansion
                    targetPinch = Math.max(0, (0.15 - handState.pinchDist) * 10);
                    targetPinch = Math.min(1.5, targetPinch); // Cap expansion
                }
                pinchExpansion += (targetPinch - pinchExpansion) * 0.1; // Smooth lerp

                // 2. Map Hand Position to Scene Rotation
                const wrist = landmarks[0];
                targetRotationY = (wrist.x - 0.5) * Math.PI * 1.5; // X axis screen maps to Y rotation
                targetRotationX = (wrist.y - 0.5) * Math.PI; // Y axis screen maps to X rotation

                // 3. Discrete Gestures (Debounced)
                if (now - lastGestureTime > GESTURE_COOLDOWN) {
                    if (handState.isPeace) {
                        currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
                        setShape(currentShapeIndex);
                        showFeedback(`Shape: ${shapeKeys[currentShapeIndex]}`);
                        lastGestureTime = now;
                    } 
                    else if (handState.isFist) {
                        currentColorIndex = (currentColorIndex + 1) % THEMES.length;
                        targetThemeColor = THEMES[currentColorIndex];
                        showFeedback("Color Changed!");
                        lastGestureTime = now;
                    }
                }
            } else {
                // Decay interactions if hand lost
                pinchExpansion *= 0.9;
                targetRotationX *= 0.95;
                targetRotationY *= 0.95;
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraFeed.start().then(() => {
            loader.style.display = 'none';
            statusText.innerText = "Camera Active - Tracking Ready";
            statusText.classList.add('ready');
        }).catch(err => {
            loader.style.display = 'none';
            statusText.innerText = "Camera access denied. Please allow camera permissions.";
            statusText.style.color = "#ff3333";
            console.error(err);
        });

        // ==========================================
        // 6. RESIZE HANDLER
        // ==========================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start 3D Loop
        animate();

    </script>
</body>
</html>